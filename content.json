{"meta":{"title":"Checo's Blog","subtitle":"","description":"","author":"Checo","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"MyBatis Plus延迟加载","slug":"MyBaits/2023-10-16_MyBatis Plus延迟加载","date":"2023-10-16T10:02:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2023/10/16/MyBaits/2023-10-16_MyBatis Plus延迟加载/","permalink":"http://example.com/2023/10/16/MyBaits/2023-10-16_MyBatis%20Plus%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"MyBatis Plus延迟加载MyBatis Plus延迟加载：MyBatis&#x2F;MyBatis Plus 是支持延迟加载的，默认没有开启，需要手动开启，以 MyBatis Plus 为例作为演示。 假设有两个用户表 order 和 user：DROP TABLE IF EXISTS `order`; CREATE TABLE `order` ( `id` int NOT NULL AUTO_INCREMENT, `user_id` int DEFAULT NULL, `order_content` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_000_ai_ci; INSERT INTO `order` VALUES (1,1,&#x27;computer&#x27;),(2,1,&#x27;phone&#x27;); DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; INSERT INTO `user` VALUES (1,&#x27;Jack&#x27;); 实体类 Order 和 User：@Data @TableName(value =&quot;order&quot;) public class Order implements Serializable &#123; private Integer id; private Integer userId; private String orderContent; &#125; @Data @TableName(value =&quot;user&quot;) public class User implements Serializable &#123; private Integer id; private String name; @TableField(exist = false) private List&lt;Order&gt; orderList; &#125; Mapper接口：@Mapper public interface OrderMapper extends BaseMapper&lt;Order&gt; &#123; @Select(&quot;select o.id, o.user_id, o.order_content from `order` o where user_id = #&#123;userId&#125;&quot;) List&lt;Order&gt; getOrderListByUserId(@Param(&quot;userId&quot;) Integer userId); &#125; @Mapper public interface UserMapper extends BaseMapper&lt;User&gt; &#123; @Select(&quot;select u.id, u.name from `user` u where id = #&#123;id&#125;&quot;) @Results(&#123; @Result(property = &quot;orderList&quot;, column = &quot;id&quot;, javaType = List.class, many = @Many(select = &quot;com.checo.mapper.OrderMapper.getOrderListByUserId&quot;, fetchType = FetchType.LAZY)) // fetchType = FetchType.LAZY 即开启延迟加载 &#125;) User getUserById(@Param(&quot;id&quot;) Integer id); &#125; 添加配置，让我们可以看到 SQL 执行日志：mybatis-plus: configuration: map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 测试延迟加载：@SpringBootTest class SpringBootDemoApplicationTests &#123; @Autowired private UserMapper userMapper; @Test public void testMyBatisPlusLazy() &#123; User jack = userMapper.getUserById(1); System.out.println(jack.getName()); System.out.println(&quot;--------------&quot;); List&lt;Order&gt; orderList = jack.getOrderList(); System.out.println(orderList); &#125; &#125; 运行结果：==&gt; Preparing: select u.id, u.name from `user` u where id = ? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, name &lt;== Row: 1, Jack &lt;== Total: 1 Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@149b0577] Jack ------- 分割线 ------- JDBC Connection [HikariProxyConnection@993343057 wrapping com.mysql.cj.jdbc.ConnectionImpl@5ec1963c] will not be managed by Spring ==&gt; Preparing: select o.id, o.user_id, o.order_content from `order` o where user_id = ? ==&gt; Parameters: 1(Integer) &lt;== Columns: id, user_id, order_content &lt;== Row: 1, 1, computer &lt;== Row: 2, 1, phone &lt;== Total: 2 [Order(id=1, userId=1, orderContent=computer), Order(id=2, userId=1, orderContent=phone)] 可以看出，在执行 jack.getOrderList() 时，才执行的订单查询，即实现了延迟加载。","categories":[{"name":"MyBais","slug":"MyBais","permalink":"http://example.com/categories/MyBais/"}],"tags":[]},{"title":"Java模拟CAS操作","slug":"Java/2023-9-21_Java模拟CAS操作","date":"2023-09-21T08:48:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2023/09/21/Java/2023-9-21_Java模拟CAS操作/","permalink":"http://example.com/2023/09/21/Java/2023-9-21_Java%E6%A8%A1%E6%8B%9FCAS%E6%93%8D%E4%BD%9C/","excerpt":"","text":"在 Java 中模拟 CAS(Compare-And-Swap) 操作CAS 基本概念科普：几乎所有的现代处理器中都包含了某种形式的原子读—改—写指令，例如比较并交换(Compare-And-Swap)，操作系统和 JVM 使用这些指令来实现锁和并发的数据结构。 CAS指令包含三个操作数，需要读写的内存地址V，进行比较的旧值A和新值B，当且仅当V中存储的值等于A时，CAS才会通过原子的方式用B值更新V中存储的值，否则不会执行任何操作。 无论V中存储的值等不等于A，都将返回V中现在存储的值，这种变化形式被称为比较并设置(Compare-And-Set)，无论操作是否成功都会返回 Java 代码模拟 CAS 操作CAS 类:/** * 模拟 CAS 操作 */ public class SimulatedCAS &#123; private int value; public SimulatedCAS(int value) &#123; this.value = value; &#125; public synchronized int get() &#123; return value; &#125; public synchronized int compareAndSwap(int expectedValue, int newValue) &#123; int oldValue = value; if (oldValue == expectedValue) value = newValue; return oldValue; &#125; public synchronized boolean compareAndSet(int expectedValue, int newValue) &#123; return (expectedValue == compareAndSwap(expectedValue, newValue)); &#125; &#125; 测试：public class Main &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; SimulatedCAS cas = new SimulatedCAS(1); // 初始化 CAS 类中的值为 1 // 开启 10 个线程竞争 CAS 操作，并且使用闭锁使得所有的线程同时开始执行 CountDownLatch startGate = new CountDownLatch(1); for (int i = 0; i &lt; 10; i++) &#123; Thread t = new Thread(() -&gt; &#123; try &#123; startGate.await(); // 将 CAS 中存储的值修改为 2 if (cas.compareAndSet(1, 2)) System.out.println(Thread.currentThread().getName() + &quot; cas succeed&quot;); else System.out.println(Thread.currentThread().getName() + &quot; cas failed&quot;); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;); t.start(); &#125; startGate.countDown(); // 使得 10 个线程同时开始竞争 CAS 操作 &#125; &#125; 结果：Thread-6 cas succeed Thread-7 cas failed Thread-9 cas failed Thread-4 cas failed Thread-3 cas failed Thread-1 cas failed Thread-5 cas failed Thread-2 cas failed Thread-8 cas failed Thread-0 cas failed 可以看到，10 个同时开始 CAS 操作的线程，只有一个会成功，其他都失败，多跑几次，成功的线程可能都是不同的。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Java中实现线程的方式","slug":"Java/2023-05-07_Java中实现线程的方式","date":"2023-05-07T10:18:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2023/05/07/Java/2023-05-07_Java中实现线程的方式/","permalink":"http://example.com/2023/05/07/Java/2023-05-07_Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Java 中实现线程的方式有两种：继承 Thread 类和实现 Runnable 接口继承 Thread 类的方式实现线程public class Main &#123; public static void main(String[] args) &#123; class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;Hello, I am a thread!&quot;); // 线程执行的逻辑 &#125; &#125; MyThread t = new MyThread(); t.start(); &#125; &#125; 实现 Runnable 接口的方式实现线程这里需要注意的是在使用实现 Runnable 接口的方式实现线程时，确实需要创建一个 Thread 对象来启动线程，但这并不意味着 Java 实现线程的本质只有一种方式，因为 Thread 类本质上只是一个线程执行的容器。 public class Main &#123; public static void main(String[] args) &#123; // Runnable 是函数式接口，可以使用 Lambda 表达式构造对象 Runnable r = () -&gt; &#123; System.out.println(&quot;Hello, I am a thread!&quot;); // 线程执行的逻辑 &#125;; Thread t = new Thread(r); t.start(); &#125; &#125; 实现 Callable 接口和使用 Future 实现线程public class Main &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Callable&lt;String&gt; callable = () -&gt; &#123; return &quot;Hello, I am a thread!&quot;; &#125;; FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(callable); // 事实上 FutureTask 实现了 Future 和 Runnable 接口 Thread t = new Thread(task); t.start(); System.out.println(task.get()); &#125; &#125; Executors 是怎么实现线程的(线程池是怎么实现线程的)？Executors 使用的是实现 Runnable 接口的方式实现线程，它提供了一种方便的方式来创建和管理线程池，可以使用 Executors 工厂方法创建不同类型的线程池。 结论使用实现 Runnable 接口的方式实现线程更加灵活，因为它可以避免单继承的限制，同时也可以更好地实现线程池等高级特性。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Java 的 Runnable、Callable、Executor 和 Future 的关系和使用例子","slug":"Java/2023-05-07_Java的Runnable、Callable、Executor和Future的关系和使用例子","date":"2023-05-07T09:28:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2023/05/07/Java/2023-05-07_Java的Runnable、Callable、Executor和Future的关系和使用例子/","permalink":"http://example.com/2023/05/07/Java/2023-05-07_Java%E7%9A%84Runnable%E3%80%81Callable%E3%80%81Executor%E5%92%8CFuture%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/","excerpt":"","text":"学了 Java 的多线程这几个接口后呢，可能还很多人傻傻分不清楚这几个接口之间到底是什么关系，有什么区别，分别有什么作用，本文简单介绍一下 Runnable、Callable、Executor 和 Future 的关系 Runnable 接口：是 Java 中的一个标准接口，用于描述一个可运行的任务。通过实现 Runnable 接口并重写 run 方法，可以定义一个线程要执行的任务内容，本身不支持返回值或抛出受检异常。 Callable 接口：与 Runnable 接口类似，也是一个标准接口，但是它可以返回一个值或者抛出一个异常。通过实现 Callable 接口并重写 call 方法，可以定义一个线程要执行的任务内容，并返回一个结果。 Executor 接口：是一个线程池管理接口，定义了线程池的执行方式和行为。通过实现 Executor 接口并重写 execute 方法，可以自定义线程池的执行策略。可以通过 Executors 中的静态工厂方法之一来创建线程池。 Future 接口：表示一个异步计算的结果，可以通过 get 方法获取计算结果。Future 接口可以用于在任务执行完成之前，先返回一个 Future 对象，然后在需要结果时再通过 get 方法获取结果。 Runnable、Callable、Executor 和 Future 的使用例子 使用 Runnable 和 Executor实现一个打印 10 个数的任务 public class Main &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService service = Executors.newSingleThreadExecutor(); // ExecutorService 接口扩展了 Executor 接口 Runnable r = () -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(i); &#125; &#125;; service.execute(r); service.shutdown(); // 关闭 ExecutorService，释放线程池资源 &#125; &#125; 使用 Callable 和 Executor 实现一个求 1 到 10 的和的任务，并输出结果 public class Main &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService service = Executors.newSingleThreadExecutor(); // ExecutorService 接口扩展了 Executor 接口 Callable task = () -&gt; &#123; int sum = 0; for (int i = 1; i &lt;= 10; i++) sum += i; return sum; &#125;; Future&lt;Integer&gt; future = service.submit(task); System.out.println(&quot;1 + 2 + ... + 10 = &quot; + future.get()); service.shutdown(); // 关闭 ExecutorService，释放线程池资源 &#125; &#125; 使用 Executor 和 Future 处理一批任务 public class Main &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executor = Executors.newFixedThreadPool(5); // 创建一批 Callable 任务 List&lt;Callable&lt;Integer&gt;&gt; taskList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; Callable&lt;Integer&gt; task = () -&gt; &#123; Thread.sleep(1000); // 模拟任务执行需要 1 秒钟 return finalI; &#125;; taskList.add(task); &#125; // 提交一批任务给 ExecutorService 并获取一个 Future 列表 List&lt;Future&lt;Integer&gt;&gt; futures = executor.invokeAll(taskList); // 遍历 Future 列表，并在每个 Future 对象上调用 get 方法以获取任务执行结果 for (Future&lt;Integer&gt; future : futures) &#123; System.out.println(&quot;Task_&quot; + future.get() + &quot;: &quot; + future.get()); &#125; executor.shutdown(); // 关闭 ExecutorService，释放线程池资源 &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Java 的访问权限修饰符","slug":"Java/2023-05-06_Java的访问权限修饰符","date":"2023-05-06T10:25:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2023/05/06/Java/2023-05-06_Java的访问权限修饰符/","permalink":"http://example.com/2023/05/06/Java/2023-05-06_Java%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"table { margin: auto; } 大家都知道，Java中的访问权限修饰符从小到大分为四种：private 、缺省、protected 和 public 修饰符 本类 本包 本包和所有子类 外部包 private √ 缺省(包访问权限) √ √ protected √ √ √ public √ √ √ √ 但是可能很多人没有真正完全的搞懂这四种访问权限修饰符在不同地方的使用限制，本文将从外部类、内部类、接口、类中的方法、接口中的方法、类中的字段和接口中的字段这 7 个角度分别解释 外部类：外部类只能使用private 或缺省这两种访问权限修饰符，且同一个 .java 文件中只允许存在一个 public 的类。 内部类：内部类的访问权限比较特殊，要分成几类来看 成员内部类：成员内部类的访问权限与其所在的外部类的访问权限没有关系。成员内部类可以使用 private 、缺省、protected 和 public 这四种访问权限修饰符。 局部内部类：声明局部内部类不能有权限修饰符，局部内部类的作用域被限定在声明这个局部类的块中 匿名内部类：没有权限修饰符 接口：接口只能使用 public 访问权限修饰符 普通类中的方法：类中的方法可以使用 private 、缺省、protected 和 public 这四种访问权限修饰符。 抽象类中的普通方法可以使用的权限修饰符和跟普通类中的方法一样，抽象类中的抽象方法，可以使用缺省、protected 和 public 这三种访问权限修饰符，抽象方法不可使用 private 修饰 接口中的方法：接口中的方法只能使用 public 访问权限修饰符，即使不写访问权限修饰符，默认也是 public。顺便一提，接口中 default 修饰的方法，它是 Java 8 新增的特性，使得接口中可以有默认实现的方法，这样实现类就不必强制实现这些方法了，主要帮助接口演化。使用 default 修饰符的方法是 public 的。值得注意的是，在 Java 9 中，接口方法被允许可以是 private 的，但是私有方法只能在接口本身访问，作用有限。 类中的字段：类中的字段可以使用 private 、缺省、protected 和 public 这四种访问权限修饰符。 接口中的字段：接口中的字段只能使用 public static final (可以省略)修饰，即使字段不写修饰符，默认也是 public static final 的，接口中的所有字段都是公共静态常量。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Java 通配符类型的限定","slug":"Java/2023-03-10_Java通配符的类型限定","date":"2023-03-10T07:22:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2023/03/10/Java/2023-03-10_Java通配符的类型限定/","permalink":"http://example.com/2023/03/10/Java/2023-03-10_Java%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A/","excerpt":"","text":"Java核心技术卷Ⅰ有一句话：带有超类型的限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象（Wildcards with supertype bounds let you write to a generic object, while wildcards with subtype bounds let you read from a generic object） 这句话怎么理解呢？ 假定有两个类： /* 人类 */ public class Person &#123; &#125; /* 学生类 */ public class Student extends Person &#123; &#125; ? extends T 表示任何实现类型 T 的子类型范围List&lt;? extends Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Student()); // 编译错误，类型不兼容 Person person = list.get(0); // 允许 因为 list 的类型参数是任何实现了 Person 类的子类，所以 list 可能是 List&lt;Teacher&gt;，也可能是 List&lt;Student&gt;，编译器并不知道可能传入的类型参数是什么，所以拒绝添加 但是你可以从中得到一个 Person 类型的对象，因为你得到的对象类型一定是 Person 类的子类 ? super T 表示任何类型 T 的父类范围List&lt;? super Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Student()); // 允许 Object person = list.get(0); // 只能读取为 Object 类型 你可以往 list 里添加学生，因为 list 的类型参数一定是 Student 的父类，父类引用指向子类对象是没有问题的 但是你从 list 取出元素时，并不知道具体的父类是什么，唯一能保证的是 Java 中所有类的超类 Object，所以你只能从中取出 Object 类型的元素","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Java 字段不参与多态性","slug":"Java/2022-11-06_Java字段不参与多态性","date":"2022-11-06T13:45:00.000Z","updated":"2025-04-12T13:25:13.438Z","comments":true,"path":"2022/11/06/Java/2022-11-06_Java字段不参与多态性/","permalink":"http://example.com/2022/11/06/Java/2022-11-06_Java%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%8F%82%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%A7/","excerpt":"","text":"两个例子例子一： 父类： public class Father &#123; int age; public Father() &#123; age = 50; &#125; &#125; 子类： public class Son extends Father &#123; public Son() &#123; age = 25; &#125; &#125; 多态的创建子类，看看年龄到底是多少： public class FieldHasNoPolymorphic &#123; public static void main(String[] args) &#123; Father guy = new Son(); System.out.println(&quot;This guy&#x27;s age is &quot; + guy.age); &#125; &#125; 例子一的输出：This guy&#39;s age is 25 很合理对吧？毕竟以前学Java SE的时候，不管是视频还是书里，都是说编译看左边，运行看右边，即父类变量的引用( guy )指向了子类对象( Son )，那么代码访问子类的年龄，自然是输出 25 例子二： 父类：同例子一 子类： public class Son extends Father &#123; // 跟例子一相比多声明了一个父类同名字段 int age; ... &#125; 同样是多态的创建子类，看看年龄是多少： public class FieldHasNoPolymorphic &#123; public static void main(String[] args) &#123; Father guy = new Son(); System.out.println(&quot;This guy&#x27;s age is &quot; + guy.age); &#125; &#125; 例子二的输出：This guy&#39;s age is 50 奇怪，明明在子类构造方法中给子类 age 初始化为了 25 ，怎么输出是 50 ？ 字段不参与多态性 字段永远不会参与多态，当子类声明父类的同名字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段 什么意思呢？假设将在父类继承而来的 age 字段叫做 ageF ，而子类中声明的 age 字段叫做 ageS ，虽然内存中这两个字段都会存在，但是子类的字段遮蔽了父类的同名字段，所以子类的构造方法中实际上是对 ageS 进行了初始化，但是通过多态创建的子类对象时，guy.age 访问的却是 ageF ，这就是为什么例子二的年龄输出是 50 而不是 25。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Java 方法参数的作用","slug":"Java/2022-09-25_Java方法参数的作用","date":"2022-09-25T12:30:00.000Z","updated":"2025-04-12T13:25:13.437Z","comments":true,"path":"2022/09/25/Java/2022-09-25_Java方法参数的作用/","permalink":"http://example.com/2022/09/25/Java/2022-09-25_Java%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"从一道题目看起 先来看一道题，请问以下最终输出的整型 a 是 100 还是 200 ？字符串 str 是 Jack 还是 Rose ？字符数组的输出 [A, B, C] 还是说 [X, B, C] ？ public class Example &#123; public static void main(String[] args) &#123; int a = 100; String str = &quot;abc&quot;; char[] ch = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;&#125;; change(a, str, ch); System.out.println(&quot;a = &quot; + a + &quot;, str = &quot; + str + &quot;, ch = &quot; + Arrays.toString(ch)); &#125; public static void change(int a, String str, char[] ch) &#123; a = 200; str = &quot;xyz&quot;; ch[0] = &#x27;X&#x27;; &#125; &#125; 实际上输出结果是：a = 100, str = abc, ch = [X, B, C]，这可能跟有些人猜测的答案有所不一样，为什么呢？嫌麻烦的朋友可以直接拉到最后看总结。 按值调用和按引用调用 按值调用(Call by Value)表示方法接收的是调用者提供的变量值，按引用调用(Call by Reference)表示方法接收的是调用者提供的变量地址。 相信很多初学 Java 的人都搞不清楚，甚至很多人到现在还搞不清楚 Java 的方法参数是值传递还是引用传递，或者是两个都有？ 一个方法是不能修改按值传递的变量值的，但是可以修改按引用传递的变量的值，熟悉 C++ 的朋友可以看以下例子(不熟悉 C++ 的朋友也可以跳过，不影响下面阅读) #include &lt;iostream&gt; using namespace std; void change(int a, int *b) &#123; a = 200; *b = 200; &#125; int main() &#123; int a = 100; int b = 100; change(a, &amp;b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; return 0; &#125; 在 Java 的方法中，只有按值调用，没有按引用调用，很多人以为 Java 方法参数是基本数据类时是按值调用，参数是对象时是引用调用，这是错误的。 Java方法参数的类型 Java 的数据类型分为基本数据类型和对象引用，很自然的方法的参数类型也就是这两种。 调用方法时，方法参数会初始化为传入实参的一个副本，基本数据类型传递的是值，对象引用则是初始化为指向实参的一个对象引用副本。 方法参数的作用 方法能不能改变基本数据类型的参数？答案是不可以。本文开头的例子可能比较抽象，形参和实参起了相同的名称，我们来看这个例子，输出结果是 x = 100，实参 x 的在调用方法后并没有得到改变。 public class Example &#123; public static void main(String[] args) &#123; int x = 100; change(x); System.out.println(&quot;x = &quot; + x); &#125; // 方法不能改变基本数据类型的参数 public static void change(int y) &#123; y = 200; &#125; &#125; 事实上形参 y 拿到的只是 x 的值的副本，并不是真的拿到了实参 x ，当 change 方法执行结束后参数变量 y 就不能再使用了，这就是为什么本文开头的代码里，a 的值依然是 100。 方法能不能改变对象的参数状态呢？答案是可以。先看一个例子，输出结果是 jack.name = Rose public class Example &#123; public static void main(String[] args) &#123; Person jack = new Person(&quot;Jack&quot;); change(jack); System.out.println(&quot;jack.name = &quot; + jack.name); &#125; // 方法可以改变对象的参数状态 public static void change(Person changePerson) &#123; changePerson.name = &quot;Rose&quot;; &#125; &#125; class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; &#125; 可以看到，jack 对象的参数从一开始的 Jack，调用方法后变为了 Rose， 调用方法时，changePerson 会初始化为 jack 值的一个副本，这里就是一个对象引用。changePerson 修改它指向的对象的 name 字段值，方法调用结束后 changePerson 不能再使用了，但是 jack 继续引用那个 name 字段值被修改过的对象。这就是为什么本文开头的例子当中，字符数组 ch 里的值能被改变的原因 方法能不能让一个对象引用一个新的对象？答案是不可以，看一个反例 public class Example &#123; public static void main(String[] args) &#123; Person jack = new Person(&quot;Jack&quot;); Person rose = new Person(&quot;Rose&quot;); swap(jack, rose); System.out.println(&quot;jack.name = &quot; + jack.name + &quot;, rose.name = &quot; + rose.name); &#125; // 企图交换两个对象引用指向的对象是白费力气 public static void swap(Person changePerson1, Person changePerson2) &#123; Person temp = changePerson1; changePerson1 = changePerson2; changePerson2 = temp; &#125; &#125; class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; &#125; 调用 swap 方法时，changePerson1 和 changePerson2 被初始化为 jack 和 rose 两个对象引用的副本，所以交换的只是这两个副本，实参的对象引用指向对象不变。值得注意的是，在 Java 中，字符串类型 String 不是一个基本数据类型，它就是一个对象，所以任何企图改变字符串引用指向的方法都将会是徒劳。 总结 方法不能修改基本数据类型的参数(即数值型或布尔型) 方法可以改变对象参数的状态 方法不能让一个对象参数引用一个新的对象","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]}],"categories":[{"name":"MyBais","slug":"MyBais","permalink":"http://example.com/categories/MyBais/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]}